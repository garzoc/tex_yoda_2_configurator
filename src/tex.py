#!/usr/bin/python3
#no_macro_header = bytearray([0x4359, 0x4649])
#print("hello")

class TexBinaryBuilder:

    keymap = {
        "s": 0x1600,
        "a": 0x0400,
        "q": 0x1400
    }

    def __init__(self):

        # Keys that does not exist within the default TEX binary file
        # Leaving them here until it can be determined what they are.
        self.unsupportedKeys = [
            0x32, # Unknown what these keys are
            0x35, # Unknown what these keys are
        ] + list(range(0x3a, 0x65)) + list(range(0x66, 0xc8)) + list(range(0xcb, 0xe0))

        self.startOfNextProfile = bytearray([
            0x02, 0x94 ,0x02, 0x00, 0x20, 0x46 ,0xff ,0xff,
            0x00, 0x00 ,0x00, 0x00 ,0x00, 0x00 ,0x00, 0x00
        ])

        # Currently not known how macros affect the binary file header but it only seems change based
        # on the number of macros so use prebuilt headers for now
        self.no_macro_header = bytearray([
            0x43, 0x59, 0x46, 0x49, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
            0x00, 0x02 ,0x00, 0x00, 0x30, 0x08, 0x00, 0x00, 0x00, 0x03 ,0x00, 0x00, 0x40, 0x10, 0x00, 0x00
        ])

        self.prebuiltFnLayer = bytearray([
            0x02, 0x20 ,0x04, 0x01 ,0x50, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x05, 0x01 ,0xf6, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x06, 0x01 ,0xf3, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x07, 0x01 ,0x4f, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x08, 0x01 ,0x3a, 0x01 ,0x00, 0x00 ,0x02 ,0x20 ,0x0c, 0x01 ,0x49, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x0f, 0x01 ,0x4d, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x11, 0x01 ,0xf4, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x12, 0x01 ,0x4a, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x13, 0x01 ,0x4b, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x14, 0x01 ,0x30, 0x01 ,0x00, 0x00 ,0x02 ,0x20 ,0x16, 0x01 ,0x51, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x19, 0x01 ,0xf5, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x1a, 0x01 ,0x52, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x1b, 0x01 ,0xf0, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x1d, 0x01 ,0xf2, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x1e, 0x01 ,0x3a, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x1f, 0x01 ,0x3b, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x20, 0x01 ,0x3c, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x21, 0x01 ,0x3d, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x22, 0x01 ,0x3e, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x23, 0x01 ,0x3f, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x24, 0x01 ,0x40, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x25, 0x01 ,0x41, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x26, 0x01 ,0x42, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x27, 0x01 ,0x43, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x29, 0x01 ,0x35, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x2a, 0x01 ,0x4c, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x2d, 0x01 ,0x44, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x2e, 0x01 ,0x45, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x2f, 0x01 ,0x46, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x30, 0x01 ,0x47, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x33, 0x01 ,0x4e, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x34, 0x01 ,0x48, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x36, 0x01 ,0x92, 0x01 ,0x00, 0x00 ,0x02 ,0x20 ,0x37, 0x01 ,0x80, 0x01 ,0x00, 0x00,
            0x02, 0x20 ,0x38, 0x01 ,0x93, 0x01 ,0x00, 0x00 ,0x02 ,0x20 ,0x09, 0x01 ,0x09, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x0a, 0x01 ,0x0a, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x0b, 0x01 ,0x0b, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x0d, 0x01 ,0x0d, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x0e, 0x01 ,0x0e, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x10, 0x01 ,0x10, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x15, 0x01 ,0x15, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x17, 0x01 ,0x17, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x18, 0x01 ,0x18, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x1c, 0x01 ,0x1c, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x28, 0x01 ,0x28, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x2b, 0x01 ,0x2b, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x2c, 0x01 ,0x2c, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x31, 0x01 ,0x31, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0x39, 0x01 ,0x39, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0x65, 0x01 ,0xe7, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xc8, 0x01 ,0xc8, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0xc9, 0x01 ,0xc9, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xca, 0x01 ,0xca, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0xe0, 0x01 ,0xe0, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xe1, 0x01 ,0xe1, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0xe2, 0x01 ,0xe2, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xe3, 0x01 ,0xe3, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0xe4, 0x01 ,0xe4, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xe5, 0x01 ,0xe5, 0x00 ,0x00, 0x00,
            0x02, 0x20 ,0xe6, 0x01 ,0xe6, 0x00 ,0x00, 0x00 ,0x02 ,0x20 ,0xe7, 0x01 ,0xe6, 0x00 ,0x00, 0x00
        ])

        # Define of the naming scheme for every layer of all three profiles
        # and add minor default configuration
        self.configs = {
            "profile1_fn_keys": {},
            "profile1_normal" : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile1_third"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile1_macro"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]}, # Calling Macro for now as it is affected by macro changes
            "profile2_fn_keys": {},
            "profile2_normal" : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile2_third"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile2_macro"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]}, # Calling Macro for now as it is affected by macro changes
            "profile3_fn_keys": {},
            "profile3_normal" : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile3_third"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]},
            "profile3_macro"  : {0x6500: [0xe7, 0x00], 0xe700: [0xe6, 0x00]}, # Calling Macro for now as it is affected by macro changes
        }

    @staticmethod
    def keyCode(*keys):
        codeList = []
        for key in keys:
            if character in TexBinaryBuilder.keymap:
                codeList.append(TexBinaryBuilder.keymap[character])
            else:
                codeList.append(None)
        return codeList

    def getConfig(self, configName):
        if configName in self.configs:
            return self.configs[configName]
        return {}

    def addConfigEntry(self, name, key, value):
        keyCode, valueCode = TexBinaryBuilder.keyCode(key, value)
        as_bytes = valueCode.to_bytes(2, "big")
        self.configs[name][keyCode] = list(as_byte)

    def setConfig(self, configs):
        for name, config in configs.items():                                    # Iterate over the list of layer configurations
            if name in self.configs:                                            # Does the layer exists
                for key, value in config.items():                               # Iterate over keys in the new config
                    if all(x in TexBinaryBuilder.keymap for x in [key, value]): # Is the key mappable
                        self.addConfigEntry(name, key, value)

    def create_key_mapping(self, key, layer, config):
        config_key = (key << 8)
        if(type(config) is dict and config_key in config):
            return bytearray([0x02, 0x20, key, layer] + config[config_key] + [0x00, 0x00])
        else:
            # With not config available fallback on default value
            return bytearray([0x02, 0x20, key, layer, key, 0x00, 0x00, 0x00])

    def keyIterator(self):
        for i in range(0x04, 0xe8):
            if i not in self.unsupportedKeys:
                yield i

    def binraryGenerate(self, filename, config):

        with open(filename, "wb") as file:
            yield "File header"
            file.write(self.no_macro_header)
            for i in range(1, 4):

                yield
                config = yield "profile{}_fn_keys".format(i)

                fn_keys = self.prebuiltFnLayer
                file.write(fn_keys)
                yield
                config = yield "profile{}_normal".format(i)

                for key in self.keyIterator():
                    file.write(self.create_key_mapping(key, 0x02, config))

                yield
                config = yield "profile{}_third".format(i)

                for key in self.keyIterator():
                    file.write(self.create_key_mapping(key, 0x03, config))
                yield
                config = yield "profile{}_macro".format(i)

                for key in self.keyIterator():
                    file.write(self.create_key_mapping(key, 0x00, config))
                yield
                config = yield "profile {} done".format(i)

                file.write(self.startOfNextProfile)

            for i in range(0, 5080):
                file.write(bytearray([0xFF]))

            yield




def init():
    texBuilder = TexBinaryBuilder()
    texBuilder.setConfig({"normal": {"s": "a"}})

    generator = texBuilder.binraryGenerate("test.txt", "step")

    #https://stackoverflow.com/questions/22028903/python-generator-send-dont-yield-a-new-value-after-a-send
    for step in generator:
        print("Creating {}".format(step))
        generator.send(texBuilder.getConfig(step))


if __name__ == "__main__":
    init()
